using System;

namespace NDceRpc.Microsoft.Interop
{
    public static class RpcRuntime
    {
        internal static readonly bool Is64BitProcess;
        public static readonly byte[] TYPE_FORMAT;
        public static readonly byte[] FUNC_FORMAT;
        internal static readonly Ptr<Byte[]> FUNC_FORMAT_PTR;

        static RpcRuntime()
        {
            Is64BitProcess = (IntPtr.Size == 8);
            RpcTrace.Verbose("Is64BitProcess = {0}", Is64BitProcess);

            if (Is64BitProcess)
            {
                //Same as 32-bit except: [8] = 8; [32] = 24;
                TYPE_FORMAT = new byte[39]
                    {
                        0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x28, 0x00, 0x08, 0x00,
                        0x01, 0x00, 0x01, 0x5b, 0x11, 0x0c, 0x08, 0x5c, 0x11, 0x14,
                        0x02, 0x00, 0x12, 0x00, 0x02, 0x00, 0x1b, 0x00, 0x01, 0x00,
                        0x28, 0x54, 0x18, 0x00, 0x01, 0x00, 0x01, 0x5b, 0x00
                    };
                //Very different from 32-bit:
                FUNC_FORMAT = new byte[61]
                    {
                        0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
                        0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x24, 0x00, 0x47, 0x05,
                        0x0a, 0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x10, 0x00,
                        0x02, 0x00, 0x50, 0x21, 0x18, 0x00, 0x08, 0x00, 0x13, 0x20,
                        0x20, 0x00, 0x12, 0x00, 0x70, 0x00, 0x28, 0x00, 0x10, 0x00,
                        0x00
                    };
            }
            else
            {
                TYPE_FORMAT = new byte[39]
                                  {
                        0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x28, 0x00, 0x04, 0x00,
                        0x01, 0x00, 0x01, 0x5b, 0x11, 0x0c, 0x08, 0x5c, 0x11, 0x14,
                        0x02, 0x00, 0x12, 0x00, 0x02, 0x00, 0x1b, 0x00, 0x01, 0x00,
                        0x28, 0x54, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x5b, 0x00
                                  };
                FUNC_FORMAT = new byte[59]
                                  {
                        0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
                        0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x24, 0x00, 0x47, 0x05,
                        0x08, 0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00,
                        0x04, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x08, 0x00, 0x02, 0x00,
                        0x50, 0x21, 0x0c, 0x00, 0x08, 0x00, 0x13, 0x20, 0x10, 0x00,
                        0x12, 0x00, 0x70, 0x00, 0x14, 0x00, 0x10, 0x00, 0x00
                                  };
            }
            FUNC_FORMAT_PTR = new Ptr<byte[]>(FUNC_FORMAT);
        }

        internal static void Free(IntPtr ptr)
        {
            if (ptr != IntPtr.Zero)
            {
                RpcTrace.Verbose("LocalFree({0})", ptr);
                NativeMethods.LocalFree(ptr);
            }
        }

        private const UInt32 LPTR = 0x0040;

        internal static IntPtr Alloc(uint size)
        {
            IntPtr ptr = NativeMethods.LocalAlloc(LPTR, size);
            RpcTrace.Verbose("{0} = LocalAlloc({1})", ptr, size);
            return ptr;
        }

        internal delegate void ServerEntryPoint(IntPtr ptr);

        internal static FunctionPtr<ServerEntryPoint> ServerEntry = new FunctionPtr<ServerEntryPoint>(NativeMethods.NdrServerCall2);
        internal static FunctionPtr<LocalAlloc> AllocPtr = new FunctionPtr<LocalAlloc>(Alloc);
        internal static FunctionPtr<LocalFree> FreePtr = new FunctionPtr<LocalFree>(Free);


    }
}