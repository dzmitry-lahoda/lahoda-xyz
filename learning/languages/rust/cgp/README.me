

What CGP helps with:

- define interface for `consumer` and `implementer`
- abstract interface over abstract `context`, which wired by few line into concrete one
- allows to extend type safety to be more reusable, without doing codegen(macroses)
- context provides certain functionalities(depdnencies)
  - along with consts and assocciated types
- provider implements certain functionaly of context
  - in Rust `provider` is impl of trait, can be only one, and only in same crate as context
  - there could be many consumers, but only one providers
    - leads to assymetry(boilerplate)
    - context generic providers can break that assymetry
- consumers can be context specififc and providers
 - cgp allows variouys levels of generalization of both
- blanket trait implementations are singular context generic providers
- method A calls method B. B constrains input to X and Y. A constraints to Z. 
   - but when A implemented it must constraint by X and Y 
     - thats is leaky abstraction
       - fixable by traits and blanket impls
       - blanke impl are way to make function more abstract
         - some constraints are only on impl
         - leads to traits bloat